[
  {
    "id": "ref-vs-reactive",
    "title": "ref vs. reactive",
    "date": "2024-01-30",
    "tags": [
      "Vue",
      "ref",
      "reactive"
    ],
    "content": "### ref vs. reactive\r\n\r\nref는 프록시 객체를 새롭게 만들고 value 속성에 원본 데이터를 넣는다\r\n\r\n따라서 `ref([])` 와 같이 하면 value 속성을 변경하여 배열을 변경할 수 있다\r\n\r\n반면, reactive는 객체 자체를 프록시화\r\n\r\n배열을 프록시화할 경우 배열에 새로운 값을 대입하면 반응성을 가지지 못한다\r\n\r\npop/push와 같은 메서드를 이용해 배열의 참조를 변경시키지 않고 값만 변경시켜야 함\r\n\r\nref, reactive API로 생성한 데이터들은 템플릿에만 한정되지 않는다. 컴포넌트와 별개로 사용할 수 있는 반응성 데이터 생성 가능\r\n\r\n[Vue 3.0 | Cracking Vue.js](https://joshua1988.github.io/vue-camp/vue3.html#composition-api%E1%84%8B%E1%85%B4-%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%B7)\r\n\r\n단, 컴포넌트 옵션 속성이 존재하기 전에 `setup()`이 실행되므로 this로 컴포넌트 접근 불가\r\n\r\n→ 대신 **context** 사용\r\n\r\n- setup API의 두 번째 인자(context)에 제공되는 옵션들\r\n  - `context.attrs`\r\n  - `context.slots`\r\n  - `context.parent`\r\n  - `context.root`\r\n  - `context.emit`\r\n\r\n[Ref, Reactive](https://velog.io/@katanazero86/Ref-Reactive)\r\n\r\n보통 ref는 primtive, reactive는 object type에 사용한다고 설명\r\n\r\n→ 코드 가독성을 위해 한 가지만 선택해 사용하는 게 좋다는 의견이 다수. `ref.value`가 반응형 데이터임을 명확히 해주어 가독성 및 유지보수에 좋음\r\n\r\nref가 **렌더 컨텍스트에서 속성으로 반환되고 템플릿에서 접근**되면, 자동적으로 내부 값을 풀어내므로 `.value`를 추가하지 않아도 된다\r\n\r\n[🔥 (#42) Ref vs. Reactive](https://michaelnthiessen.com/weekly-042-january-05/)\r\n\r\n1. 객체를 감쌀 때는 ref를 사용해 해당 객체가 반응형임을 명시적으로 보여준다\r\n2. watch 메서드 사용 시, refs는 자동적으로 감싼 객체를 풀어주어 사용이 용이하다\r\n3. refs를 reactive 객체로 감쌀 수 있는데, 이는 reactive 객체이자 ref 객체로서 해당 객체를 사용할 수 있도록 한다\r\n\r\n[🔥 (#49) When ref and reactive are the same](https://michaelnthiessen.com/weekly-049-february-23/)\r\n\r\n**ref와 reactive가 동일하게 동작할 때**도 있다.\r\n\r\nwatchEffect를 사용할 때랑, template에서 조회할 때.\r\n\r\n<aside>\r\n⭐ **Proxy**란\r\n\r\n[JavaScript Proxy Explained Clearly By Practical Examples](https://www.javascripttutorial.net/es6/javascript-proxy/)\r\n\r\n다른 객체를 감싸 기본 연산(속성 조회, 할당, 열거 및 함수 호출 등)을 가로채는 객체\r\n\r\n- `get()`\r\n  대상 객체의 속성이 프록시 객체를 통해 접근될 때 발생\r\n- `set()`\r\n  대상 객체의 속성이 설정될 때 발생.\r\n- `apply()`\r\n  함수 호출\r\n\r\n</aside>\r\n\r\n### Vue 3가 Proxy를 사용하는 방법\r\n\r\n[](https://levelup.gitconnected.com/when-vue-meets-proxy-402e9e3c6722)\r\n\r\nVue2에서는 Object.definedProperty()를 사용하여 getter/setter를 통해 프로퍼티를 변경\r\n\r\n→ 프로퍼티의 삭제나 추가는 추적이 어려움, 중첩되거나 양이 많은 데이터의 경우 모든 속성의 getter/setter 생성을 필요로 함\r\n\r\n→ Vue3에서 Proxy 채택!\r\n\r\nVue의 중요 특성은 변동성 감지, Proxy를 사용함으로써 새로운 프로퍼티 추적이나 개선된 처리를 보여준다\r\n\r\nProxy를 사용함으로써 객체에 대한 모든 호출이나 접근을 가로채어 다룰 수 있게 됨\r\n\r\n프로퍼티가 존재하지 않는 경우, 새로운 프로퍼티를 생성하고 알릴 수 있다 → Vue2의 단점 개선\r\n\r\n프록시 구현 시 데이터의 모든 속성을 타고 내려갈 필요 없어짐 → 대용량 데이터 처리 성능 향상"
  },
  {
    "id": "SFC-CSS",
    "title": "SFC CSS",
    "date": "2024-01-30",
    "tags": [
      "Vue",
      "SFC",
      "CSS"
    ],
    "content": "[SFC CSS Features | Vue.js](https://vuejs.org/api/sfc-css-features.html?ck_subscriber_id=1762872175&utm_source=convertkit&utm_medium=email&utm_campaign=%F0%9F%94%A5+%28%2390%29+Destructuring+in+a+v-for%20-%209582658#sfc-css-features)\r\n\r\n## Deep Selectors\r\n\r\nstyle scoped에서 지정한 CSS 값을 자식 컴포넌트까지 전달하고 싶을 경우 사용\r\n\r\n```css\r\n<style scoped>\r\n.a :deep(.b) {\r\n\t/* ... */\r\n}\r\n</style>\r\n```\r\n\r\n## Slotted Selectors\r\n\r\n기본값으로 scoped styles는 slot 내에 렌더링되는 컨텐츠에 영향을 끼치지 않는다.\r\n\r\nslot 컨텐츠를 명시적으로 타겟팅하기 위해서 사용\r\n\r\n```css\r\n<style scoped>\r\n\t:slotted(div) {\r\n\t\tcolor: red;\r\n\t}\r\n</style>\r\n```\r\n\r\n## Global Selectors\r\n\r\n하나의 선택자만 전역적으로 CSS를 적용하고 싶을 때 사용\r\n\r\n```css\r\n<style scoped>\r\n\t:global(.red) {\r\n\t\tcolor: red;\r\n\t}\r\n</style>\r\n```\r\n\r\n## CSS Modules\r\n\r\n`<style module>` 태그는 CSS Module로 컴파일되며, CSS 클래스를 `$style` 키 값을 가진 객체로 만들어 컴포넌트 template 태그 내에서 사용할 수 있도록 한다\r\n\r\n```css\r\n<template>\r\n  <p :class=\"$style.red\">This should be red</p>\r\n</template>\r\n\r\n<style module>\r\n.red {\r\n  color: red;\r\n}\r\n</style>\r\n```\r\n\r\nmodule 어트리뷰트에 값을 지정하면 커스텀 키 값을 지정할 수 있다\r\n\r\n```css\r\n<template>\r\n  <p :class=\"classes.red\">red</p>\r\n</template>\r\n\r\n<style module=\"classes\">\r\n.red {\r\n  color: red;\r\n}\r\n</style>\r\n```\r\n\r\n### Composition API\r\n\r\nuseCssModule 메서드를 사용\r\n\r\n```css\r\nimport { useCssModule } from 'vue'\r\n\r\n// inside setup() scope...\r\n// default, returns classes for <style module>\r\nuseCssModule()\r\n\r\n// named, returns classes for <style module=\"classes\">\r\nuseCssModule('classes')\r\n```\r\n\r\n## v-bind() in CSS\r\n\r\nvue의 data 값을 style 태그 내에서 사용 가능\r\n\r\n```css\r\n<template>\r\n  <div class=\"text\">hello</div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      color: 'red'\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style>\r\n.text {\r\n  color: v-bind(color);\r\n}\r\n</style>\r\n\r\n//script setup\r\n<script setup>\r\nconst theme = {\r\n  color: 'red'\r\n}\r\n</script>\r\n\r\n<template>\r\n  <p>hello</p>\r\n</template>\r\n\r\n<style scoped>\r\np {\r\n  color: v-bind('theme.color');\r\n}\r\n</style>\r\n```"
  },
  {
    "id": "the-6-levels-of-reusability",
    "title": "[번역] The 6 Levels of Reusability",
    "date": "2024-01-30",
    "tags": [
      "Vue",
      "번역",
      "reusability"
    ],
    "content": "[The 6 Levels of Reusability](https://michaelnthiessen.com/6-levels-of-reusability/)\r\n\r\n모든 개발자는 적은 코드로 많은 것을 얻길 원한다.\r\n\r\n이를 위해 우리는 컴포넌트를 만들어 한 번 이상 이를 재사용하고자 한다.\r\n\r\n어떤 컴포넌트는 기본적인 재사용성만 필요하지만, 어떤 것은 더 복잡한 기술이 필요하다.\r\n\r\n저자는 6단계의 재사용성을 확인했으나, 이보다 더 많은 재사용성이 있을 것.\r\n\r\n## 1. Templating\r\n\r\n여기저기에 복사, 붙여넣기를 하는 것 대신 하나의 컴포넌트 안에 해당 코드를 묶어 놓는다.\r\n\r\n컴포넌트를 재사용하는 것에는 두 가지 장점이 있다\r\n\r\n1. 미래에 변경사항이 있을 때 보다 쉽게 수정이 가능하다. 한 곳의 코드만 수정하면 되기 때문\r\n2. 복사해서 사용한 코드의 위치를 일일이 기억할 필요 없다.\r\n\r\n→ 가장 기본적인 재사용성\r\n\r\n## 2. Configuration\r\n\r\n몇몇 컴포넌트들은 작동하는 방식에 따라 변동이 있다.\r\n\r\n예를 들면 Button 컴포넌트가 있다고 했을 때, 이는 아이콘만 있는 상위 버전이 있을 수 있음.\r\n\r\n아예 새로운 컴포넌트를 생성하는 대신 props를 이용해 다른 타입을 전환할 수 있다.\r\n\r\nprops를 사용하는 것은 컴포넌트 사용에 있어 보다 유연성을 부여한다.\r\n\r\n## 3. Adaptability\r\n\r\nconfiguration의 가장 큰 문제점은 통찰이 부족하다는 것이다.\r\n\r\n개발자는 미래의 니즈를 예측하여 컴포넌트 내에 props를 넣어야 한다.\r\n\r\n하지만 개발자가 컴포넌트를 적용 가능하게 만든다면, 이는 컴포넌트를 변경할 필요 없이 다양하게 사용할 수 있도록 할 것이다.\r\n\r\n우리는 이를 slot을 통해 구현할 수 있다.\r\n\r\n예를 들어 text prop을 Button 컴포넌트 안에 넣는 대신, 우리는 default slot을 이용할 수 있다.\r\n\r\n이런 경우 개발자는 string이나 number와 같은 타입에 구애받지 않는다.\r\n\r\n만약 버튼 안에 spinner를 넣고 싶다면, slot의 경우 얼마든지 가능하다.\r\n\r\n## 4. Inversion\r\n\r\n위와 유사하게 복잡한 markup을 child component에 전달하는 대신 렌더링에 대한 지침을 전달할 수 있다.\r\n\r\n이는 테이크아웃을 주문하는 대신 레시피를 따르는 것과 같다.\r\n\r\n레시피를 따르는 데에는 조금 더 품이 따르지만, 개발자는 본인이 만드는 모든 것을 컨트롤할 수 있다.\r\n\r\n우리는 scoped slots를 사용함으로써 우리의 컴포넌트에 더 복잡한 코드를 재사용하기 쉽게 추가할 수 있다.\r\n\r\n[Scoped Slot | Cracking Vue.js](https://joshua1988.github.io/vue-camp/reuse/scoped-slot.html#%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%86%B8%E1%84%83%E1%85%B3-%E1%84%89%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%86%BA-%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B3-%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8)\r\n\r\n## 5. Extension\r\n\r\nAdaptability와 Inversion과 함께 우리는 컴포넌트의 재사용성을 극대화할 수 있는 필수적인 기술이 있다.\r\n\r\n다음 단계는 이 기술을 컴포넌트 전역에 추가함으로써 더 쉽게 그 목적을 확장하는 것이다.\r\n\r\n우리는 named slots를 통해 하나 이상의 포인트를 컴포넌트에 추가할 수 있다.\r\n\r\n우리는 이를 통해 수많은 다른 옵션을 컴포넌트의 다양한 포인트에 적용할 수 있다.\r\n\r\n<aside>\r\n⭐ Vue 3에서는 scoped slots, named slots의 기능을 통합한 v-slot 기능이 추가되었다.\r\n\r\n[v-slot | Cracking Vue.js](https://joshua1988.github.io/vue-camp/reuse/v-slot.html#v-slot-%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC-%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8)\r\n\r\n</aside>\r\n\r\n## 6. Nesting\r\n\r\n마지막은 이러한 extension 포인트들을 하나 이상의 컴포넌트 레이어에 넘기는 것이다.\r\n\r\n개발자는 일반적인 기본 컴포넌트에서 개발을 시작한다. 그 다음 컴포넌트는 조금 더 구체적이고 기본 컴포넌트를 확장하는 형식일 것이다. 그렇다면 실제로 원하는 동작을 하는 마지막 컴포넌트까지 이 일을 반복한다.\r\n\r\n이는 정확히 `Animal → Mammal → Dog → Poodle` 과 같은 구체화 과정을 거치는 것이다.\r\n\r\n우리는 이 과정을 통해 `Mammal → Cat, Tiger, Lion`과 같은 다양화된 컴포넌트 제작도 할 수 있다."
  },
  {
    "id": "typescript란",
    "title": "타입스크립트 기초",
    "date": "2022-05-25",
    "tags": [
      "TS"
    ],
    "content": "## 타입스크립트란\r\n\r\n자바스크립트에 타입을 부여한 언어\r\n\r\n자바스크립트의 확장된 언어\r\n\r\n→ 브라우저에서 실행하려면 파일을 한 번 변환해 주어야 한다(컴파일)\r\n\r\n### Why Typescript?\r\n\r\n- 에러의 사전 방지\r\n- 코드 가이드 및 자동 완성으로 인한 개발 생산성 향상\r\n\r\n## 기본 타입\r\n\r\n- `Boolean`\r\n- `Number`\r\n- `String`\r\n- `Object`\r\n- `Array`\r\n- `Tuple`\r\n  배열 길이 고정, 요소 타입 지정\r\n- `Enum`\r\n\r\n  상수들의 집합, 인덱스로도 접근 가능\r\n\r\n- `Any`\r\n- `Void`\r\n  변수에 undefined와 null만 할당, 리턴값 X\r\n- `Null`\r\n- `Undefined`\r\n- `Never`\r\n  절대 함수의 끝까지 실행되지 않음을 의미\r\n\r\n<aside>\r\n⭐ Any는 보통 TypeScript 원칙에 위배된다고 사용하지 않을 것을 권한다. 그럼 Any는 언제 사용하는가?\r\n\r\n→ js에서 ts로 **마이그레이션**할 때 사용한다\r\n\r\nallowJS를 해놓고 any로 일단 해놓은 다음 점진적으로 바꾼다\r\n\r\n</aside>\r\n\r\n## 함수\r\n\r\n- 함수의 파라미터(매개변수) 타입\r\n  타입스크립트에서는 함수의 인자를 필수값으로 간주\r\n  정의된 매개변수 값만 받을 수 있고 추가로 인자를 받을 수 없음\r\n  → 특성을 살리고 싶다면 `?` 이용\r\n  ```jsx\r\n  function sum(a: number, b?: number): number {\r\n    return a + b;\r\n  }\r\n  sum(10, 20);\r\n  sum(10);\r\n  ```\r\n- 함수의 반환 타입\r\n- 함수의 구조 타입\r\n\r\n### this\r\n\r\n타입스크립트에서는 자바스크립트의 this가 잘못 사용되었을 때 감지 가능\r\n\r\nthis가 가리키는 것을 명시하려고 할 때 다음과 같이 사용\r\n\r\n```jsx\r\nfunction fcName(this: type) {\r\n  //...\r\n}\r\n```\r\n\r\n콜백으로 함수가 전달되었을 때의 this를 구분해주어야 할 때는 다음과 같이 사용\r\n\r\n```jsx\r\ninterface UIElement {\r\n  //'this:void' 코드는 함수에 'this' 타입을 선언할 필요가 없다는 의미\r\n  addClickListener(onclick: (this: void, e: Event) => void): void;\r\n}\r\n\r\nclass Handler {\r\n  info: string;\r\n  onClick(this: void, e: Event) {\r\n    console.log(\"clicked\");\r\n  }\r\n}\r\n\r\nlet handler = new Handler();\r\nuiElement.addClickListener(handler.onClick);\r\n```\r\n\r\n---\r\n\r\n## 인터페이스\r\n\r\n상호 간에 정의한 약속 혹은 규칙\r\n\r\n타입스크립트에서는 다음과 같은 범주에 대해 약속 정의 가능\r\n\r\n- 객체의 스펙(속성과 속성 타입)\r\n- 함수의 파라미터\r\n- 함수의 스펙(파라미터, 반환 타입 등)\r\n- 배열과 객체를 접근하는 방식\r\n- 클래스\r\n\r\n타입스크립트는 인터페이스를 이용하여 객체를 선언할 때 좀 더 엄밀한 속성 검사를 진행\r\n\r\n### 옵션 속성\r\n\r\n인터페이스 사용 시 인터페이스에 정의되어 있는 속성을 모두 다 사용할 필요 없다\r\n\r\n```jsx\r\ninterface CraftBeer {\r\n  name: string;\r\n  hop?: number;\r\n}\r\n\r\nlet myBeer = {\r\n  name: \"Saporo\",\r\n};\r\nfunction brewBeer(beer: CraftBeer) {\r\n  console.log(beer.name); //Saporo\r\n}\r\nbrewBeer(myBeer);\r\n```\r\n\r\nBeer 인터페이스를 인자의 타입으로 사용해도 hop은 옵션 속성이므로 없어도 가능\r\n\r\n→ 인터페이스를 사용할 때 속성을 선택적으로 적용할 수 있다는 것뿐 아니라 인터페이스에 정의되어 있지 않은 속성에 대해 인지시켜줄 수 있다\r\n\r\n### `readonly`읽기 전용 속성\r\n\r\n인터페이스로 객체를 처음 생성할 때만 값을 할당하고 그 이후에는 변경할 수 없음\r\n\r\n`ReadonlyArray<T>` 읽기 전용 배열 → 배열 내용 변경 불가\r\n\r\n### 함수 타입\r\n\r\n함수의 인자 타입과 리턴 값의 타입 지정\r\n\r\n```jsx\r\ninterface login {\r\n  (username: string, password: string): boolean;\r\n}\r\n\r\nlet loginUser: login;\r\nloginUser = function (id: string, pw: string) {\r\n  console.log(\"로그인했습니다\");\r\n  return true;\r\n};\r\n```\r\n\r\n### 클래스 타입\r\n\r\n클래스가 일정 조건을 만족하도록 타입 규칙 지정\r\n\r\n```jsx\r\ninterface CraftBeer {\r\n  beerName: string;\r\n  nameBeer(beer: string): void;\r\n}\r\n\r\nclass myBeer implements CraftBeer {\r\n  beerName: string = \"Baby Guinness\";\r\n  nameBeer(b: string) {\r\n    this.beerName = b;\r\n  }\r\n  constructor() {}\r\n}\r\n```\r\n\r\n### 인터페이스 확장\r\n\r\n인터페이스 간 확장이나 여러 인터페이스를 상속 받아 사용하는 것 가능\r\n\r\n```jsx\r\ninterface Person {\r\n\tname: string;\r\n}\r\ninterface Developer extends Person {\r\n\tskill: string;\r\n}\r\nlet fe = {} as Developer;\r\nfe.name = 'josh';\r\nfe.skill = 'Typescript';\r\n```\r\n\r\n```jsx\r\ninterface Person {\r\n\tname: string;\r\n}\r\ninterface Drinker {\r\n\tdrink: string;\r\n}\r\ninterface Developer extends Person {\r\n\tskill: string;\r\n}\r\nlet fe = {} as Developer;\r\nfe.name = 'josh';\r\nfe.skill = 'Typescript';\r\nfe.drink = 'Beer';\r\n```\r\n\r\n### 하이브리드 타입\r\n\r\n여러 타입을 조합하여 생성 가능 → 함수 타입이면서 객체 타입 정의 가능\r\n\r\n```jsx\r\ninterface CraftBeer {\r\n\t(beer: string): string;\r\n\tbrand: string;\r\n\tbrew(): void;\r\n}\r\n\r\nfunction myBeer(): CraftBeer {\r\n\tlet my = (function(beer: string) {}) as CraftBeer;\r\n\tmy.brand = 'Beer Kitchen';\r\n\tmy.brew = function(){}\r\n\treturn my;\r\n}\r\n\r\nlet brewedBeer = myBeer();\r\nbrewdBeer('My First Beer');\r\nbrewedBeer.brand = 'Pangyo Craft';\r\nbrewedBeer.brew();\r\n```\r\n\r\n---\r\n\r\n## Enum\r\n\r\n특정 값들의 집합을 의미하는 자료형\r\n\r\n- 문자형 enum\r\n- 숫자형 enum\r\n\r\n런타임 시 객체로 존재하지만, `keyof` 대신 `keyof typeof` 사용 권고\r\n\r\n### 숫자형 enum\r\n\r\n```jsx\r\nenum Direction {\r\n\t//초기값을 주면 초기값부터 1씩 증가\r\n\tUp = 1, //1\r\n\tDown, //2\r\n\tLeft, //3\r\n\tRight //4\r\n}\r\n\r\nenum Direction {\r\n\t//초기값을 주지 않으면 0부터 차례로 1씩 증가\r\n\tUp, //0\r\n\tDown, //1\r\n\tLeft, //2\r\n\tRight //3\r\n}\r\n```\r\n\r\n선언 시 만약 enum 값에 다른 enum 타입의 값을 사용하면 선언하는 enum의 첫 번째 값에 초기화 필요\r\n\r\n- 리버스 매핑\r\n  숫자형에만 가능\r\n  enum의 key로 value를 얻을 수 있고, value로 key를 얻는 것 가능\r\n  ```jsx\r\n  enum Enum {\r\n  \tA\r\n  }\r\n  let a = Enum.A;\r\n  let keyName = Enum[a];\r\n  ```\r\n\r\n### 문자형 enum\r\n\r\n숫자형 enum과는 런타임에서의 미세한 차이 존재\r\n\r\nenum값 전부 다 특정 문자 또는 다른 enum 값으로 초기화 필요\r\n\r\n숫자형과 다르게 자동 값 증가가 없는 대신, 디버깅 시 항상 명확한 값이 나와 읽기 편하다(숫자형은 가끔 값이 불명확하게 나올 때가 있음)\r\n\r\n```jsx\r\nenum Direction {\r\n\tUp = \"UP\",\r\n\tDown = \"DOWN\",\r\n\tLeft = \"LEFT\",\r\n\tRight = \"RIGHT\"\r\n}\r\n```\r\n\r\n### 복합 enum(Heterogeneous Enums)\r\n\r\n기술적은 문자와 숫자를 혼합하여 생성 가능하나, 권고 X\r\n\r\n---\r\n\r\n## 연산자\r\n\r\n### `|` Union Type\r\n\r\nA이거나 B이다\r\n\r\nany를 사용하는 경우 타입스크립트를 빠져나와 변수의 타입에 대한 제한이 없어진다\r\n\r\n그러나 유니온 타입을 사용하면 타입스크립트의 이점인 타입에 제한을 두는 것은 그대로 작동한다\r\n\r\n```jsx\r\nfunction getAge(age: number | string) {\r\n  if (typeof age === \"number\") {\r\n    age.toFixed();\r\n    return age;\r\n  }\r\n  if (typeof age === \"string\") {\r\n    return age;\r\n  }\r\n  return new TypeError(\"age must be number or string\");\r\n}\r\n```\r\n\r\n### `&` Intersection Type\r\n\r\n여러 타입을 모두 만족하는 하나의 타입\r\n\r\n```jsx\r\ninterface Person {\r\n  name: string;\r\n  age: number;\r\n}\r\ninterface Developer {\r\n  name: string;\r\n  skill: number;\r\n}\r\n//Person 인터페이스의 타입 정의와 Developer 인터페이스의 타입 정의를 & 연산자를 이용하여 합친 후 Capt라는 타입에 할당\r\ntype Capt = Person & Developer;\r\n```\r\n\r\n---\r\n\r\n## 클래스\r\n\r\n### `readonly`\r\n\r\n접근만 가능\r\n\r\n### Accessor\r\n\r\n타입스크립트는 객체의 특정 속성의 접근과 할당에 대해 제어 가능\r\n\r\n단, 해당 객체가 클래스로 생성한 객체여야 한다\r\n\r\n```jsx\r\nclass Developer {\r\n\tprivate name: string;\r\n\r\n\tget name(): string {\r\n\t\treturn this.name;\r\n\t}\r\n\tset name(newValue: string) {\r\n\t\tif(newValue && newValue.length > 5) {\r\n\t\t\tthrow new Error('이름이 너무 길어요');\r\n\t\t}\r\n\t\tthis.name = newValue;\r\n\t}\r\n}\r\nconst josh = new Developer();\r\njosh.name = 'Josh Bolton';//Error\r\njosh.name = 'Josh';\r\n```\r\n\r\n이때, getter만 선언하면 자동으로 readonly로 인식된다\r\n\r\n### Abstract Class\r\n\r\n특정 클래스의 상속 대상이 되는 클래스\r\n\r\n좀 더 상위 레벨에서 속성, 메서드의 모양을 정의\r\n\r\n```jsx\r\nabstract class Developer {\r\n\tabstract coding(): void;\r\n\tdrink(): void {\r\n\t\tconsole.log('drink');\r\n\t}\r\n}\r\n\r\nclass FrontEndDeveloper extends Developer {\r\n\t//Developer를 상속 받았으므로 무조건 정의해야 함\r\n\tcoding(): void {\r\n\t\tconsole.log('develop web');\r\n\t}\r\n\tdesign(): void {\r\n\t\tconsole.log('design web');\r\n\t}\r\n}\r\n\r\nconst dev = new Developer(); //Error 인터페이스는 인스턴스 생성 불가\r\nconst josh = new FreontEndDeveloper();\r\njosh.coding();\r\njosh.drink();\r\njosh.design();\r\n```\r\n\r\n---\r\n\r\n## 제네릭\r\n\r\n타입을 마치 함수의 파라미터처럼 사용하는 것\r\n\r\n타입스크립트에서 함수 호출 시 넘긴 타입에 대해 추정하여 해당 타입을 부여\r\n\r\n---\r\n\r\n## 타입 추론\r\n\r\n타입스크립트가 코드를 해석해 나가는 동작\r\n\r\n변수를 선언하거나 초기화할 때, 변수, 속성, 인자의 기본 값, 함수의 반환 값 등을 설정할 때 타입 추론 발생\r\n\r\n타입스크립트는 **값의 형태**에 기반한 타입 체크를 지향한다\r\n\r\n- `Duck Typing`\r\n  객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미\r\n  사람이 오리처럼 행동하면 오리로 봐도 무방하다\r\n  타입을 미리 정하는 게 아니라 실행이 되었을 때 해당 메서드들을 확인하여 타입을 정한다\r\n- `Structual Subtyping`\r\n  객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미\r\n  서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다\r\n  타입이 계층구조로부터 자유로움\r\n  [Structural Subtyping](https://medium.com/@seungha_kim_IT/structural-subtyping-346af4dffe77)\r\n\r\n---\r\n\r\n## 타입 호환\r\n\r\n타입스크립트 코드에서 특정 타입이 다른 타입에 잘 맞는지를 의미\r\n\r\n```jsx\r\ninterface Ironman {\r\n  name: string;\r\n}\r\nclass Avengers {\r\n  name: string;\r\n}\r\n\r\nlet i: Ironman;\r\ni = new Avengers();\r\n```\r\n\r\n→ 구조적 타이핑(Structual Subtyping) 때문\r\n\r\n타입스크립트가 추론한 i의 타입은 {name: string;}\r\n\r\nIronman 인터페이스에서 name 속성을 갖고 있으므로 i, Avengers 인스턴스는 Ironman 타입에 호환될 수 있다\r\n\r\n### Soundness\r\n\r\n컴파일 시점에 타입을 추론할 수 없는 특정 타입에 대해서 일단 안전하다고 보는 특성\r\n\r\n### enum 타입 호환 주의사항\r\n\r\nenum 타입은 number 타입과 호환되지만, enum 타입끼리는 호환되지 않는다\r\n\r\n### class 타입 호환 주의사항\r\n\r\n클래스 타입은 클래스 타입끼리 비교할 때 static member와 constructor를 제외하고 속성만 비교\r\n\r\n### Generics\r\n\r\n제네릭 타입 간의 호환 여부는 타입 인자 <T>가 속성에 할당되었는지를 기준으로 한다\r\n\r\n---\r\n\r\n## 타입 별칭\r\n\r\n특정 타입이나 인터페이스를 참조할 수 있는 타입 변수\r\n\r\n새로운 타입 값을 하나 생성하는 것이 아니라 정의한 타입에 대해 나중에 쉽게 참고할 수 있게 이름을 부여하는 것\r\n\r\n### type vs. interface\r\n\r\n[Documentation - Everyday Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces)\r\n\r\n타입의 확장 가능/불가능 여부\r\n\r\n인터페이스는 확장이 가능한데 반해 타입 별칭은 확장이 불가능하다 → 버전이 업그레이드되면서 수정되었다. 이제는 둘 다 확장 가능\r\n\r\n인터페이스는 객체 및 메서드 객체에서, type은 함수, 복잡한 type 등에서 사용\r\n\r\n[Types vs. interfaces in TypeScript - LogRocket Blog](https://blog.logrocket.com/types-vs-interfaces-in-typescript/)\r\n\r\ntype은 primitive type에도 사용이 가능하다. 새로 정의하는 것이 아니라 별칭을 부여하는 것이기 때문\r\n\r\n반면, 인터페이스는 객체로만 선언이 가능하다.\r\n\r\n둘 다 extends, implements 사용이 가능하지만, union type은 사용이 불가능\r\n\r\nType으로 만들어진 정적 타입에 extends, implements 키워드가 사용 가능한 사실은 공식 문서에 명시되어 있지 않다고 함"
  },
  {
    "id": "vue-lifecycle",
    "title": "Vue Lifecycle",
    "date": "2024-01-30",
    "tags": [
      "Vue",
      "lifecycle"
    ],
    "content": "1. Creation\r\n2. Mounting\r\n3. Updating\r\n4. Destruction\r\n\r\n## Vue2\r\n\r\n- 라이프 사이클 속성 : 인스턴스의 상태에 따라 호출할 수 있는 속성들\r\n- 라이프 사이클 훅 : 각 라이프 사이클 속성에서 실행되는 커스텀 로직(개발자가 임의로 작성한 추가 로직)\r\n\r\n인스턴스의 생성 → 인스턴스 화면 부착 → 부착된 인스턴스 내용 갱신 → 인스턴스 제거\r\n\r\n- `beforeCreate`\r\n  인스턴스가 생성되고 나서 가장 처음으로 실행되는 단계\r\n  data 속성과 methods 속성이 아직 인스턴스에 정의되어 있지 않다.\r\n  따라서 DOM과 같은 화면 요소에도 접근 불가능\r\n- `created`\r\n  data 속성과 methods 속성이 정의된 이후\r\n  DOM 요소 접근은 불가(아직 인스턴스가 화면에 부착되지 않음)\r\n- `beforeMount`\r\n  template 속성에 지정한 마크업 언어를 render() 함수로 변환한 후 el속성에 지정한 화면 요소(돔)에 인스턴스를 부착하기 전 호출\r\n    <aside>\r\n    💡 render()\r\n    \r\n    자바스크립트로 화면의 돔을 그리는 함수\r\n    \r\n    </aside>\r\n\r\n- `mounted`\r\n  el속성에서 지정한 화면 요소에 인스턴스가 부착되고 나면 호출\r\n  template 속성에 정의한 화면 요소(돔)에 접근 가능 → 화면 요소 제어 로직 수행에 용이함\r\n  단, 돔에 인스턴스가 부착되자마자 바로 호출되므로 최종 HTML 코드로 변환되는 시점과 다를 수 있음\r\n- `beforeUpdate`\r\n  관찰하고 있는 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출\r\n  변경 예정인 새 데이터에 접근할 수 있어 변경 예정 데이터의 값과 관련된 로직을 미리 넣을 수 있음\r\n  값 변경 로직을 넣더라도 화면이 다시 그려지지는 않는다(인스턴스는 이미 부착되었고, 화면에 치환되는 중이므로)\r\n- `updated`\r\n  데이터 변경 후 가상 돔으로 다시 화면을 그리고나면 실행되는 단계\r\n  데이터 변경으로 인한 화면 요소 변경까지 완료된 시점이므로 데이터 변경 후 화면 요소 제어와 관련된 로직을 추가하기 좋음\r\n  데이터 값 변경 시 무한루프에 빠질 수 있다 → computed나 watch 사용\r\n  데이터 값 갱신 로직은 beforeUpdate에, 변경 데이터의 화면 요소(돔)와 관련된 로직은 updated에!\r\n- `beforeDestroy`\r\n  뷰 인스턴스가 파괴되기 직전에 호출\r\n  아직 인스턴스에 접근 가능하므로 뷰 인스턴스의 데이터를 삭제하기 좋다\r\n- `destroyed`\r\n  뷰 인스턴스가 파괴되고 나서 호출되는 단계\r\n  뷰 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스들 또한 모두 파괴\r\n\r\n데이터가 변경되지 않는 경우\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64d42e63-0038-475a-81d9-5acd20aeeb0b/Untitled.png)\r\n\r\n데이터가 변경되는 경우\r\n\r\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b94ce1ac-f662-4f66-97cf-88d97c1dafaf/Untitled.png)\r\n\r\n## Vue3\r\n\r\n컴포넌트를 생성하여 DOM 노드 트리에 마운트하고, 불필요한 엘리먼트를 제거하는 일련의 과정\r\n\r\n컴포지션 API로 setup 함수 내에서 생명주기 훅을 사용하기 위해서는 컴포지션 함수를 이용해야 한다.\r\n\r\n```jsx\r\nsetup() {\r\n\tonUpdated(() => {\r\n\t\t//Update Action\r\n\t})\r\n}\r\n```\r\n\r\n- `beforeCreate`\r\n  **컴포넌트를 생성하기 전**에 호출\r\n  컴포지션 API의 setup 함수 자체가 beforeCreate를 대체한다.\r\n  컴포넌트가 생성되기 전에 호출이 되므로 생성한 data는 물론, 해당 data를 관찰할 수 있는 watch와 같은 함수들이 동작하지 않음\r\n- `created`\r\n  **컴포넌트가 생성**되면 호출\r\n  컴포지션 API의 setup 함수가 created 대체\r\n  컴포넌트의 옵션에 접근이 가능하므로 data 옵션에 선언한 데이터들을 초기화할 때 주로 사용\r\n- `beforeMount(onBeforeMount)`\r\n  **Vue의 가상 노드가 render 함수를 호출하기 직전(실제 DOM을 구성하기 직전)**에 호출\r\n  beforeMount 사이클이 지나고나면 Vue는 Virtual DOM에 가상으로 Rendering할 DOM을 미리 구성한다. → onRenderTracked라는 생명주기 훅을 통해 관찰 가능\r\n- `mounted(onMounted)`\r\n  **실제로 컴포넌트의 구성요소들이 DOM 엘리먼트로 마운트된 후** 호출\r\n  이 때부터 **실제 엘리먼트 참조 가능**\r\n    <aside>\r\n    ⭐ 실제 엘리먼트가 참조 가능하다는 것은?\r\n    \r\n    mounted 사이클 이전까지는 ref와 같은 함수를 통해 엘리먼트의 참조변수를 만들어도 초기화한 값만 들어있고 실제 엘리먼트를 참조할 수 X\r\n    \r\n    mounted부터는 해당 변수를 통해 실제 엘리먼트에 접근할 수 있게 되는 것!\r\n    \r\n    </aside>\r\n    \r\n    실제 엘리먼트에 동적으로 변화를 줘야 할 경우 처리하기 좋음\r\n    \r\n    onRenderTriggered 라는 생명주기 훅이 이후 호출 → 실제 엘리먼트를 참조한다는 것은 Virtual DOM이 실제 DOM에 반영 되었음을 의미하기 때문!\r\n\r\n- `beforeUpdate(onBeforeUpdated)`\r\n  **데이터가 변경되었지만 아직 DOM에 반영되지 않았을 때** 호출\r\n  이미 DOM을 구성하는 요소가 있는데, Virtual DOM이 수정되고 이 수정사항이 DOM에 반영되기 직전에 호출되는 것\r\n  아직 변경사항이 DOM에 반영되지 않았으므로, 실제 엘리먼트를 참조하는 변수로부터 아무것도 얻을 수 없음\r\n- `updated(onUpdated)`\r\n  **데이터가 변경되어 DOM이 변경 완료된 시점**에 호출\r\n  이 순간부터 DOM이 업데이트되었다고 보고, 해당 DOM에 참조된 변수를 이용해 다양한 역할 수행 가능\r\n  단, 현재 컴포넌트만 수정이 되었음을 보장하는 것으로 해당 엘리먼트의 자식 노드들이 업데이트가 완료되었다고 보장하지는 않는다\r\n    <aside>\r\n    ⭐ 자식 컴포넌트까지 모두 수정된 것을 기다리고 싶다면?\r\n    \r\n    nextTick을 이용해 완료되길 기다려야 한다\r\n    \r\n    ```jsx\r\n    updated() {\r\n    \tthis.$nextTick(function() {\r\n    \t\t//모든 자식이 업데이트되었다.\r\n    \t})\r\n    }\r\n    ```\r\n    \r\n    </aside>\r\n\r\n- `beforeUnmount(onBeforeUnmount)`\r\n  **컴포넌트가 탈착되기 직전**에 호출\r\n  아직 모든 기능을 사용할 수 있는 상태이므로, 명시적으로 컴포넌트가 Unmount되기 전에 해줘야 할 것들을 작성\r\n- `unmounted(onUnmounted)`\r\n  **컴포넌트가 탈착되고 나서** 호출\r\n  이 순간부터 모든 디렉티브와 이벤트가 사용이 불가능해진다\r\n- `activated(onActivated)`\r\n  keep-alive 태그는 컴포넌트가 다시 렌더링되는 것을 방지하고, 상태를 유지하기 위해 쓰인다\r\n  일반적으로 v-is 디렉티브와 함께 쓰여 해당 디렉티브가 컴포넌트를 변경할 때 기존 컴포넌트의 상태가 사라지지 않게 하기 위해 사용\r\n  이러한 **keep-alive 태그로 컴포넌트의 상태가 보존되기 시작하면** onActivated 생명주기 훅 함수 호출\r\n- `deactivated(onDeactivated)`\r\n  **keep-alive로 상태가 유지되고 컴포넌트가 효력을 상실**하면 호출\r\n- `renderTracked(onRenderTracked)`\r\n  **Virtual DOM이 변경될 때마다** 관찰을 목적으로 호출\r\n  이 함수를 통해 DebuggerEvent 객체를 살펴보면 어떠한 이유로 Virtual DOM이 변경이 되는지 확인 가능\r\n    <aside>\r\n    ⭐ DebuggetEvent\r\n    \r\n    target이란 속성을 통해서 Virtual DOM을 변경시키는 것을 추적할 수 있다\r\n    \r\n    </aside>\r\n\r\n- `renderTriggered(onRenderTriggered)`\r\n  **Virtual DOM이 DOM으로 반영이 되어야 할 때** 호출\r\n  onMounted, onActivated, onUpdated와 같이 실제 DOM이 변경되기 직전에 호출됨을 확인 가능\r\n  어떤 이유로 렌더링이 호출되었는지 파악하기 위해서는 DebuggerEvent를 살펴보면 된다\r\n- `errorCaptured(onErrorCaptured)`\r\n  자손 컴포넌트에 에러가 발생하면 어느 컴포넌트에서 어떤 에러가 발생했는지 알려준다\r\n  실제 동작 중에 이러한 에러가 발생하면 안되기에 일반적으로 개발 중 에러를 캡쳐하기 위해 사용"
  },
  {
    "id": "vue3-핵심-문법",
    "title": "Vue 3 핵심 문법",
    "date": "2024-01-30",
    "tags": [
      "Vue"
    ],
    "content": "## Vue3 핵심 문법\r\n\r\n### Single File Component\r\n\r\nVue의 컴포넌트를 하나의 파일로 나타내는 것을 의미\r\n\r\n하나의 파일이 하나의 컴포넌트를 나타내므로 관리가 쉽고 코드가 간결해진다.\r\n\r\n- `template`\r\n  컴포넌트가 렌더링되어야 하는 HTML 코드 부분. 선언적 렌더링 혹은 템플릿 문법을 이용해 반응형 컴포넌트 생성 가능\r\n- `script`\r\n  템플릿에서 사용한 반응성을 가지는 변수 등을 조작 가능\r\n  자바스크립트나 타입스크립트 등을 이용해 스크립트 코드 작성\r\n    <aside>\r\n    ⭐ Vue 3에서 components 옵션을 이용해 컴포넌트를 지정하지 않아도 되는 이유\r\n    \r\n    `<script setup>` 이라는 Vue의 신규 기능 덕분. 내부적으로 <template>을 render() 함수로 변경하기 때문에 명시적으로 변수나 컴포넌트를 노출시킬 필요가 없다.\r\n    \r\n    setup() 함수를 직접 구현하는 경우 기존 Options API와 마찬가지로 components 옵션으로 컴포넌트를 지정해줘야 한다.\r\n    \r\n    </aside>\r\n\r\n- `style`\r\n  컴포넌트 혹은 전체 프로젝트에서 사용할 CSS 코드 삽입 가능\r\n    <aside>\r\n    ⭐ `<style scoped>`\r\n    \r\n    정의한 CSS가 component 내에서만 적용되게 한다\r\n    \r\n    </aside>\r\n\r\n### setup\r\n\r\nVue 3는 컴포지션 API를 이용해 컴포넌트를 만들 수 있는데, 이 컴포지션 API는 setup 함수 내에서 사용이 가능하다.\r\n\r\nsetup 함수 내에 자바스크립트로 코드를 작성하고, 객체 형식으로 반환한다.\r\n\r\n```jsx\r\nsetup() {\r\n\tconst data = 1;\r\n\treturn { data };\r\n}\r\n```\r\n\r\n### 선언적 렌더링\r\n\r\nVue는 선언적 렌더링을 지원한다 == 변수를 선언하고 값을 넣으면 자동으로 DOM에 업데이트가 된다\r\n\r\n- v-html 디렉티브를 이용한 HTML 표현\r\n  HTML 엘리먼트의 innerHTML 값에 변수값을 전달하기 때문에 문자열이 HTML 마크업 언어로 표현되도록 함\r\n  innerHTML에 바로 값을 집어 넣기 때문에 변수는 반드시 HTML 평문이어야 하며, Vue의 문법을 사용해도 컴파일 되지 않음\r\n- v-pre 디렉티브를 이용한 컴파일 무시\r\n  해당 엘리먼트를 포함한 모든 자식 엘리먼트들의 값을 컴파일하지 않는다\r\n  수염표기법으로 변수를 표기하더라도 있는 그대로 출력됨\r\n\r\n### 데이터 결합을 통한 사용자 입력 처리\r\n\r\n템플릿 내에서 v-bind 디렉티브 혹은 v-model 디렉티브를 이용할 경우 컴포넌트에서 선언한 변수와 HTML 태그의 속성을 결합할 수 있음\r\n\r\n주의할 것은 v-bind 디렉티브는 단방향 결합을 지원하고, v-model 디렉티브를 양방향 결합을 지원한다는 것\r\n\r\n- v-model 디렉티브 수식어\r\n  v-model 디렉티브는 변수의 값을 변경할 수 있는 수식어가 존재한다\r\n  유용하지만 Vue 3의 세부 버전에 따라 수식어가 작동되기도 하고 안되기도 하므로 가능하면 내부 구현을 통해 처리하거나 사용자 수식어를 생성해 처리하는 것이 좋음\r\n  - `.lazy` changed 이벤트와 동기화되어 값 변경\r\n  - `.number` 넘어오는 값을 자동으로 숫자로 타입 변경\r\n  - `.trim` 값의 좌우 여백을 잘라냄\r\n    <aside>\r\n    ⭐ 사용자 수식어를 만드는 방법\r\n\r\n    v-model 디렉티브로 연결되는 변수명을 컴포넌트의 props에 정의하고, 변수명 뒤에 Modifiers라는 글자를 붙여 props에 추가적으로 선언\r\n\r\n    </aside>\r\n\r\n### 이벤트 리스너를 이용한 사용자 입력 처리\r\n\r\nHTML 태그가 발생시키는 이벤트를 캡쳐하여 지정된 스크립트를 수행하거나 함수를 호출하기 위해 v-on 디렉티브를 이용\r\n\r\n- 이벤트 수식어\r\n  Vue의 v-on 디렉티브는 이벤트 함수 호출을 이벤트 핸들러 메서드에서 하지 않고 이벤트를 받는 태그에서 할 수 있는 수식어를 제공한다\r\n  이벤트 핸들러 메서드 내에서는 추가적으로 필요한 코드만 작성할 수 있으므로 훨씬 가독성이 높고 재사용 가능한 코드를 만드는데 좋다\r\n  연결해서 사용 가능\r\n  - `.stop` 이벤트 전파를 방지 == stopPropagation()\r\n  - `.prevent` 브라우저의 기본 동작을 금지 == preventDefault()\r\n  - `.capture` 이벤트리스너의 capture(이벤트가 자식 엘리먼트로 전달되기 전 호출) 옵션 활성화\r\n  - `.self` 이벤트가 자식 엘리먼트가 아닌 현재 엘리먼트에서 발생했을 때만 핸들러 호출\r\n  - `.once` 최대 한 번의 클릭만 허용\r\n    .once.prevent와 같이 사용하면 처음 클릭 시 태그의 본연 기능을 방지하고 원하는 기능 수행 가능\r\n  - `.passive` 이벤트리스너의 passive 옵션(true일 경우 preventDefault() 호출 X) 활성화\r\n  - `.exact` 정확히 해당 키만 눌렀을 때 핸들러 호출\r\n  - `.left` 마우스의 왼쪽 버튼이 눌렸을 때 핸들러 호출\r\n  - `.right` 마우스의 오른쪽 버튼이 눌렸을 때 핸들러 호출\r\n  - `.middle` 마우스의 가운데 버튼이 눌렸을 때 핸들러 호출\r\n- 키 수식어\r\n  일반적으로 keyup 이벤트에 대해 수식어를 붙여 키보드 입력을 수정\r\n\r\n### 템플릿 내 조건문(v-if)\r\n\r\nv-if 디렉티브를 사용한 조건문으로 일반적으로 스크립트 문법을 따른다\r\n\r\n주의할 것은 이미 디렉티브가 쌍따옴표를 통해 스크립트를 구성하므로 문자열을 표시할 때는 반드시 홑따옴표를 이용해야 한다는 것\r\n\r\n`v-show`\r\n\r\nv-if 디렉티브와 비슷한 역할을 한다\r\n\r\nv-if는 조건이 변경되면 조건 내 DOM 엘리먼트를 처음부터 다시 그리는 반면, v-show는 일단 모든 조건의 DOM 엘리먼트를 그린 후 조건에 맞지 않는 엘리먼트는 hide 처리한다\r\n\r\nv-if는 빠르게 애플리케이션의 그림을 그려주지만 조건이 변경될 때마다 다시 해당 엘리먼트를 그려야하는 반면, v-show는 처음에는 조금 늦게 그릴지 몰라도 조건이 자주 변경될 때는 매우 빠른 전환이 이뤄진다\r\n\r\n→ **조건이 자주 안바뀔 경우 v-if가 유리하며 조건이 자주 바뀐다면 v-show가 유리하다**\r\n\r\n### 템플릿 내 반복문(v-for)\r\n\r\n간단한 배열이나 객체의 표현에 사용\r\n\r\nv-for 디렉티브를 사용할 때면 언제나 key 속성을 같이 적어주는 것이 좋음\r\n\r\n→ 템플릿이 가상 DOM 렌더함수로 변환될 때 같은 태그를 재활용하기 때문\r\n\r\n### Computed 속성\r\n\r\n실시간으로 원하는 대로 데이터 변경\r\n\r\n내부 반응성 변수의 값이 변하지 않는다면 그 결과를 캐시에서 바로 꺼내 사용, DOM 업데이트 자체를 진행하지 않는다\r\n\r\n(함수는 호출이 되면 반드시 새롭게 계산을 진행하고 DOM을 업데이트한다)\r\n\r\n```jsx\r\nsetup() {\r\n\tconst small_items_c = computed(() => {\r\n\t\treturn arr.filter((i) => i.id < 3)\r\n\t})\r\n\tconst big_items_c = computed(() => {\r\n\t\treturn arr.filter((i) => i.id >= 3)\r\n\t})\r\n\r\n\treturn {\r\n\t\tsmall_items_c,\r\n\t\tbig_items_c\r\n\t}\r\n}\r\n```\r\n\r\n### Watch와 WatchEffect\r\n\r\n데이터의 변화를 감지하여 사용자가 지정한 콜백함수를 호출할 수 있게 해주는 기능\r\n\r\n- watch\r\n  개발자가 코드로 지정한 변수값의 변화를 감시하여 콜백함수로 하여금 부가적인 작업을 할 수 있도록 해준다\r\n    <aside>\r\n    ⭐ 지정된 특정한 변수의 감시와 더불어 값이 변경되기 이전 값을 참조할 수 있음!\r\n    \r\n    → watch는 변수가 할당되기 전의 null값에서 초기값으로 넘어가는 과정을 데이터의 변경으로 판단하지 않지만, 같은 컴포넌트를 다시 불러올 때(reload) props의 처음 값이 중요할 때가 있다\r\n    \r\n    이때 **immediate 속성을 true**로 하면 처음 값 조회가 가능\r\n    \r\n    </aside>\r\n    \r\n    여러 변수를 동시에 감시하기 위해서는 watch의 처음 인자를 배열로 주면 된다. 배열의 값들이 변화가 일어나면 배열의 순서대로 변화된 값을 콜백함수에 배열로 전달한다.\r\n    \r\n    <aside>\r\n    ⭐ 감시하고자 하는 대상이 객체나 리스트일 때\r\n    \r\n    → deep 옵션을 true로 설정\r\n    \r\n    </aside>\r\n\r\n- watchEffect\r\n  Vue 3에서 새롭게 소개한 기능으로 매우 강력한 감시능력을 제공\r\n  초기 변경값부터 감시를 시작\r\n  기본적으로 어떤 값이 변경되었는지 알려주지 않고, 어떤 값이 변경되었는지 모르므로 과거값도 알 수 없음\r\n  불필요한 변수를 모두 감시하지 않기 위해 모든 변수의 대입값을 감시한 후에는 콜백함수에서 참조되는 변수만 감시\r\n  생성 시 **반환함수**를 받아 감시의 중단을 위해 활용 가능\r\n  - `flush` 사용하지 않으면 ‘pre’가 기본값이며, ‘pre’와 ‘post’ 중 하나를 선택 가능\r\n    - pre : DOM이 업데이트하기 전에 콜백함수를 호출하라는 뜻\r\n    - post : DOM이 업데이트된 후 콜백함수를 호출해 달라는 뜻\r\n\r\n### 컴포넌트 생성\r\n\r\n하나의 커다란 애플리케이션을 작은 요소로 분해해 은닉화를 하고 재사용성을 가지게 해주는 Vue의 매우 중요한 요소 중 하나\r\n\r\n하나의 애플리케이션은 createApp 함수를 이용해 생성된 Vue 애플리케이션 인스턴스를 참조해야 한다\r\n\r\n```jsx\r\nimport { createApp } from \"vue\";\r\nconst app = createApp({\r\n  /* 인스턴스 옵션들 */\r\n});\r\n```\r\n\r\n이 애플리케이션 인스턴스는 몇 개의 메서드를 제공하며, 이 메서드를 이용하여 정의한 것들은 애플리케이션의 모든 컴포넌트가 사용할 수 있는 전역의 범위로 선언된다\r\n\r\n<aside>\r\n⭐ **전역 범위로 선언할 수 있게 해주는 애플리케이션 인스턴스 메서드**\r\n\r\n- `component`\r\n  컴포넌트의 이름과 함수 혹은 객체로 이루어진 컴포넌트 정의를 인자로 받아 컴포넌트를 생성한다\r\n- `config`\r\n  [Application API | Vue.js](https://vuejs.org/api/application.html#app-config)\r\n  애플리케이션의 전역 설정을 담당하는 객체로 mount 메서드가 불리기 전에 설정을 해야 한다\r\n  - errorHandler : 컴포넌트를 그리거나 감시할 때 에러가 발생하면 호출\r\n  - warnHandler : Vue에서 경고를 발생시킬 때 호출\r\n  - globalProperties : 키와 값을 설정\r\n  - isCustomElement : 특정한 조건을 설정하여 Vue에서 생성되지 않은 컴포넌트를 명시\r\n  - optionMergeStrategies : 사용자 정의 속성이 있고, 부모 컴포넌트와 자식 컴포넌트가 해당 속성을 정의했을 때 두 값을 어떻게 처리할지 함수로 정의 가능\r\n  - performance : devtool의 performance/timeline 패널에 성능 관련 정보 추적할 수 있게 해줌\r\n- `directive`\r\n  전역 사용자 디렉티브를 설정할 수 있다\r\n- `mixin`\r\n  전역에서 사용할 수 있는 mixin을 설정한다\r\n- `mount`\r\n  최상위 컴포넌트를 특정 DOM 엘리먼트에 장착한다\r\n- `provide`\r\n  모든 자식 컴포넌트가 inject할 수 있는 값을 provide한다\r\n- `unmount`\r\n  특정 DOM 엘리먼트 내 애플리케이션 인스턴스를 탈착한다\r\n- `use`\r\n  Vue 플러그인 객체를 사용할 수 있게 해준다\r\n\r\n</aside>\r\n\r\n- Props\r\n  컴포넌트에 데이터를 넘겨줄 수 있는 사용자 지정 속성\r\n  컴포넌트 생성 시에 props 옵션을 이용해 어느 이름의 props 데이터를 받을지 결정한다\r\n  일반적으로 props라는 옵션에 Props로 넘어오는 속성의 키 값들을 배열로 지정하면 사용에 문제 X\r\n  그러나 어떤 컴포넌트는 특정한 Props를 반드시 필요로 할 수도 있고, 정해진 데이터 타입에 맞게 들어왔는지 확인히 필요할 수 도 있다 → 옵션의 값을 배열 대신 객체로 변경하고 각 Props 데이터의 상세 내용을 지정!\r\n  - `type` 데이터 타입을 정의한다\r\n  - `default` 해당 Props가 들어오지 않을 경우 사용할 기본값을 가지며, 데이터 타입이 Object일 경우 반드시 팩토리 함수를 이용해 값을 반환해야 함\r\n  - `required` true로 설정되고 Props가 안 들어오면 콘솔에 경고, default가 설정되어 있으면 default값이 쓰여 경고를 내보내지 않음\r\n  - `validator` 잘못 들어온 인자를 개발자 코드로 직접 검사해 콘솔창에 경고를 낼 수 있음\r\n- Non-Prop 속성\r\n  props나 emits 옵션에 정의되지 않은 컴포넌트의 속성(Class, Style, id속성 등)\r\n  스크립트 코드에서 $attrs를 이용해 접근 가능\r\n  Vue 3의 setup 컴포지션 함수에서 Non-Prop 속성에 접근하기 위해서는 setup 함수의 두 번째 매개변수인 context를 이용해야 한다\r\n  ```jsx\r\n  setup(props, context) {\r\n  \tconst title = context.attrs.title\r\n  }\r\n  ```\r\n  Non-Props 속성은 템플릿 내 루트 노드에 상속된다.\r\n  - `inheritAttrs` false일 경우 자식 노드에서 Non-Prop 속성($attr)을 상속하지 않는다\r\n\r\n### 사용자 이벤트 생성\r\n\r\n이벤트를 정의하기 위해서는 컴포넌트의 emits 옵션에 이벤트명을 지정하면 된다\r\n\r\n가능하면 케밥형식의 소문자만 사용한다\r\n\r\n단순히 이벤트명의 배열로 만들어도 되지만, Props를 정의할 때와 마찬가지로 객체형식을 이용해 이벤트 전달값이 올바른지 판단할 수 있다.\r\n\r\n- v-model 디렉티브와 이벤트 결합\r\n  기본적으로 v-model 디렉티브에 연동된 변수는 컴포넌트의 Props에 연동이 된다\r\n  이렇게 전달된 변수의 값은 컴포넌트 안에서 업데이트되어 변수를 전달한 부모 컴포넌트와 동기화 가능\r\n  Vue 3는 하나의 v-model 뿐만 아니라 **여러 개의 v-model 디렉티브를 지원**하므로 props에 v-model 디렉티브를 위한 변수를 여러 개 설정하고 emits에도 동일하게 설정하면 여러 개의 값을 양방향으로 결합할 수 있다\r\n  ```jsx\r\n  props: {msg: String, type: String}\r\n  $emit('update:msg', $event.target.value)\r\n  $emit('update:type', $event.target.value)\r\n  ```\r\n\r\n### Slots\r\n\r\n시작태그와 종료태그 사이에 들어가는 값\r\n\r\n```jsx\r\n<Component>\r\n\tSlot_value\r\n</Component>\r\n\r\n//Component 컴포넌트\r\n<button><slot></slot></button>\r\n```\r\n\r\n```jsx\r\n<button>Slot_value</button>\r\n```\r\n\r\n슬롯을 생성할 때 미리 지정된 값을 넣는 것도 가능(아무런 값이 입력되지 않았을 때 사용되는 기본값이 된다)\r\n\r\n여러 개의 슬롯 정의도 가능, 이 경우 하나의 기본 슬롯을 제외하고 나머지는 항상 name 속성 제공 필요\r\n\r\n- `v-slot` name 속성을 가지는 slot에 데이터를 삽입할 때 사용, `<template>` 태그를 이용해 사용한다\r\n  ```jsx\r\n  <Component>\r\n    <template v-slot:header>Header</template>\r\n    <template v-slot:default>Default</template>\r\n  </Component>\r\n  ```\r\n- 데이터 전달\r\n  - `Slot Props` 하나의 컴포넌트에서 발생된 데이터를 Slot에 결합시키고 싶을 경우, 해당 컴포넌트에 작성한 <slot> 태그에 Non-Prop을 정의하면 된다.\r\n\r\n### Provide/Inject\r\n\r\n컴포넌트 간 데이터 전달\r\n\r\n- `Provide` 부모 컴포넌트에서 자식 컴포넌트들과 공유할 데이터를 정의할 때 사용\r\n- `Inject` 부모가 넣은 데이터를 접근할 때 사용\r\n\r\n기본적으로 반응성을 가지진 않지만, ref/reactive/computed 등과 같은 함수를 이용해 반응성을 가지는 변수는 Provide할 경우 Inject된 값 역시 반응성을 갖게 된다\r\n\r\n### 사용자 디렉티브\r\n\r\ndirective 함수를 이용해 디렉티브명을 적고 엘리먼트가 DOM에 마운트됐을 때의 액션을 작성하면 사용자가 정의한 디렉티브를 사용할 수 있다\r\n\r\n```jsx\r\napp.directive(\"focus\", {\r\n  mounted(el) {\r\n    el.focus();\r\n  },\r\n});\r\n//el : 디렉티브가 사용된 특정 HTML 엘리먼트\r\n//사용시에는 v- 라는 접두사를 붙여 Vue의 디렉티브임을 알려줘야 한다\r\n```\r\n\r\nmounted와 updated 모두 적용되게 하고 싶을 경우 훅 이름을 지정하지 않은 무기명 함수를 선언\r\n\r\n```jsx\r\napp.directive(\"focus\", (el) => {\r\n  el.focus();\r\n});\r\n```\r\n\r\n디렉티브는 속성 및 값을 전달받을 수 있다\r\n\r\n- `v-디렉티브:속성 = “값”`\r\n- `v-디렉티브 = “값”`\r\n- `v-디렉티브`\r\n\r\n속성과 값을 가진 변수는 훅 함수의 두 번째 매개변수에 키-값 형태로 들어온다\r\n\r\n일반적으로 두 번째 매개변수의 이름을 binding이라고 한다\r\n\r\n**binding 함수가 갖고 있는 속성**\r\n\r\n- `instance` 디렉티브가 사용된 컴포넌트 인스턴스를 나타낸다\r\n- `value` 디렉티브로 전달된 값\r\n- `oldValue` beforeUpdate 혹은 updated 훅 함수 사용 시 이전 값을 나타낸다\r\n- `arg` 속성값을 나타낸다\r\n- `modifiers` 수식어가 사용됐다면 수식어를 나타낸다\r\n- `dir` 디렉티브 객체를 반환한다\r\n\r\n훅 함수는 el과 binding 외 vnode와 prevNode 인자를 제공\r\n\r\n- `vnode` Vue가 생성해내는 el 엘리먼트의 가상노드\r\n- `prevNode` update 혹은 beforeUpdate 훅 함수에서만 사용 가능한, 변경되기 직전의 가상노드\r\n\r\n### Mixins\r\n\r\n컴포넌트의 옵션과 동일한 옵션들을 모두 정의할 수 있다\r\n\r\n→ Mixins를 호출하는 컴포넌트와 충돌\r\n\r\n<aside>\r\n⭐ Mixins는 컴포넌트보다 먼저 호출된다\r\n\r\n</aside>\r\n\r\n컴포넌트의 변수나 함수의 이름이 Mixins와 충돌하는 문제를 제거하기 위해 Mixins의 변수나 함수명은 가능하면 특정한 규칙을 갖는 게 좋다"
  }
]